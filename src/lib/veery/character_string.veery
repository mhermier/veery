
import "veery/abort" for Abort;
import "veery/assert" for Assert;
import "veery/magnitude" for Magnitude;

class Character is Magnitude {
  static init_() {
    if (__enum != null) return;
    __enum = {};

    (0..256).each {|codePoint|
      .fromCodePoint(codePoint);
    };
  }

  construct new_(codePoint, toString) {
    // TODO validation

    _codePoint = codePoint;
    _toString  = toString;

    __enum[_codePoint] = this;
    __enum[_toString]  = this;
  }

  static new(value) {
    if (value is Character) {
      return this;
    }
    if (value is CharacterString) {
      Assert.call(value.count == 1, "invalid argument");
      return value[0];
    }
    if (value is Num) {
      return .fromCodePoint(value);
    }
    if (value is String) {
      return .fromString(value);
    }

    Fiber.abort("Value must be a Character, a CharacterString, a String or a Num");
  }

  static fromCodePoint(codePoint) {
    var c = __enum[codePoint];
    if (c != null) return c;

    return new_(codePoint, String.fromCodePoint(codePoint));
  }

  static fromEscapedString(escapedString) {
    return fromString(unescapeString_(escapedString));
  }

  static fromString(string) {
    var c = __enum[string];
    if (c != null) return c;

    var codePoints = string.codePoints;
    Assert.call(codePoints.count == 1, "invalid argument");
    return new_(codePoints[0], string);
  }

  // Fixme should be part of String
  static unescapeString_(escapedString) {
    var string = "";

    var it;
    var escapedStringCodePoints = escapedString.codePoints;
    while (it = escapedStringCodePoints.iterate(it)) {
      var c = Character.fromCodePoint(escapedStringCodePoints.iteratorValue(it));

      if (c == '\\') {
        it = escapedStringCodePoints.iterate(it);
        c = Character.fromCodePoint(escapedStringCodePoints.iteratorValue(it));

        // TODO: make an static map for wellknown values
        if (c == '\\') {
          c = '\\';
        } else if (c == '"') {
          c = '"';
        } else if (c == '%') {
          c = '%';
        } else if (c == '\'') {
          c = '\'';
        } else if (c == '0') {
          c = '\0';
        } else if (c == 'a') {
          c = '\a';
        } else if (c == 'b') {
          c = '\b';
        } else if (c == 'e') {
          c = '\e';
        } else if (c == 'f') {
          c = '\f';
        } else if (c == 'n') {
          c = '\n';
        } else if (c == 'r') {
          c = '\r';
        } else if (c == 't') {
          c = '\t';
/*
        } else if (c == 'u') {
          c = readUnicodeEscape(4);
        } else if (c == 'U') {
          c = readUnicodeEscape(8);
 */
        } else if (c == 'v') {
          c = '\v';
/*
        } else if (c == 'x') {
          c = (uint8_t)readHexEscape(parser, 2, "byte");
 */
        } else {
          Fiber.abort("Invalid escape character '%(c)'.");
        }
      }

      string = string + c.toString;
    }

    return string;
  }

//  <=>(other) { _codePoint <=> other.codePoint }
  ==(other) { other is Character && _codePoint == other.codePoint }
  < (other) { other is Character && _codePoint < other.codePoint }

  +(rhs) {
    if (rhs is Character) return CharacterString.fromCharacters([this, rhs]);
    if (rhs is CharacterString) return CharacterString.fromCharacters([this] + rhs.characters);
    if (rhs is String) return this + CharacterString.fromString(rhs); // TODO: Remove compatibility ?

    Abort.runtime_error("Right hand side must be a character or a character string.");
  }

  *(count)   { CharacterString.filled(count, this) }

  ..(rhs)    {    return CharacterString.fromCharacters(
                      (this.codePoint..rhs.codePoint).map {|codePoint|
                          return Character.fromCodePoint(codePoint)});
             }
  ...(rhs)   {    return CharacterString.fromCharacters(
                      (this.codePoint...rhs.codePoint).map {|codePoint|
                          return Character.fromCodePoint(codePoint)});
             }

  hash { Abort.todo() }

  codePoint { _codePoint }
  toString    { _toString  }

  isAlpha {
    return isLower ||
           isUpper ||
           this == '_';
  }

  isDigit { this >= '0' && this <= '9' }

  isAlphaNumeric { isAlpha || isDigit }

  isHexDigit {
    return isDigit ||
           this >= 'a' && this <= 'f' ||
           this >= 'A' && this <= 'F';
  }

  isLower { this >= 'a' && this <= 'z' }
  isUpper { this >= 'A' && this <= 'Z' }

  isPrintable { this >= ' ' && this != Character.fromCodePoint(0x7f) }
}

class CharacterString {
  construct new_(characters, toString) {
    _characters = characters;
    _toString = toString;
  }

  static filled(size, character) {
    return .fromCharacters(List.filled(size, character));
  }

  static fromCharacters(characters) {
    return new_(characters.toList, // TODO ToList<Character>(characters)
                characters.join());
  }

  static fromString(string) {
    Assert.call(string is String, "Argument must be a string");

    var characters = []; // TODO: should reserve
    for (codePoint in string.codePoints) {
      characters.add(Character.fromCodePoint(codePoint));
    }
    return new_(characters, string);
  }

  [subscript] {
    if (subscript is Num) return _characters[subscript];
    if (subscript is Range) return CharacterString.fromCharacters(_characters[subscript]);

    Abort.runtime_error("Subscript must be a number or a range.");
  }

  ==(rhs) {
    if (rhs is Character) Abort.TODO();
    if (rhs is CharacterString) return toString == rhs.toString;
    if (rhs is String) return toString == rhs; // TODO: Remove compatibility ?

    Abort.runtime_error("Right hand side must be a character or a character string.");
  }
  !=(rhs) { !(this == rhs) }

  <(rhs) { Abort.TODO() }
  <=(rhs) { Abort.TODO() }
  >(rhs) { Abort.TODO() }
  >=(rhs) { Abort.TODO() }

  +(rhs) {
    if (rhs is Character) Abort.TODO();
    if (rhs is CharacterString) return CharacterString.fromCharacters(_characters + rhs.characters);
    if (rhs is String) return this + CharacterString.fromString(rhs); // TODO: Remove compatibility ?

    Abort.runtime_error("Right hand side must be a character or a character string.");
  }

  count { _characters.count }
  characters { _characters }
  isEmpty { _characters.count == 0 }

  toString { _toString }

  iterate(iterator) { _characters.iterate(iterator) }
  iteratorValue(iterator) { _characters.iteratorValue(iterator) }
}

Character.init_();
