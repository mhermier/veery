
import "io" for Directory, File

import "veery/argument_parser" for ArgumentParser;
import "veery/character_string" for CharacterString
import "veery/compiler/abstract_lang/composed_visitor" for ComposedVisitor
import "veery/compiler/abstract_lang/source_file" for SourceFile
import "veery/compiler/abstract_lang/transform_visitor" for TransformVisitor
import "veery/compiler/reporter" for JsonReporter, PrettyReporter, Reporter;
import "veery/veery_version" for VEERY_VERSION_STRING;

import "veery_lang/lexer" for Lexer
import "veery_lang/parser" for Parser

import "veery/compiler/abstract_lang/transform/constant_folding_transform/constant_folding_transform" for ConstantFoldingTransform
import "veery/compiler/abstract_lang/transform/character_transform" for CharacterTransform
import "wren_lang/source_printer" for SourcePrinter
import "wren_lang/transform/enum_transform" for EnumTransform
import "wren_lang/transform/strict_equality_transform" for StrictEqualityTransform
import "wren_lang/transform/this_module_transform" for ThisModuleTransform

import "veery/compiler/abstract_lang/validator/call_receiver_validator" for CallReceiverValidator

class Compiler {
  construct new () {}

  parseFile(path) {
//    System.print("Parsing %(path)")
    var code = CharacterString.fromString(File.read(path))
    var source = SourceFile.new(path, code)
    var parser = Parser.from_source(source, _reporter)
    var ast = parser.parseModule()

//    var resolver = Resolver.new(_reporter)
//    resolver.resolve(ast)

    return ast
  }

  run(arguments) {
    var language;
    var reporter_class = PrettyReporter;

    var argument_parser = ArgumentParser.new {|argument_parser|
      argument_parser.program_name    = "veery compile";
      argument_parser.program_version = VEERY_VERSION_STRING;

      // Compatibility option: add some ouput format option
      argument_parser.add_option {|option|
        option.long_name = "json";
        option.help      = "Output result in json format";
        option.callback  = Fn.new {
          reporter_class = JsonReporter;
        }
      }

      argument_parser.add_option {|option|
        option.long_name = "lang";
        option.help      = "Change the language";
        option.arity     = 1;
        option.callback  = Fn.new {|result|
          // TODO Check values
          language = result.arguments_shift();
        }
      }
    }

    var result = argument_parser.parse(arguments);
    arguments = result.arguments;

    _reporter = Reporter.new(reporter_class.new());

    if (language != null) {
      System.print("Support other languages than veery");
      return 1;
    }

    // FIXME Handle arguments more gracefully
    if (arguments.count != 2) {
      System.print("Usage: veery-c <source file> <output file>")
      return 1
    }

    var path = arguments[0]
    var ast = parseFile(path)
    //System.print(ast)

    var file = File.create(arguments[1])
    var visitor = SourcePrinter.new(file)

    // veery

    // wren
    if (true)  visitor = ComposedVisitor.new(visitor, CharacterTransform.new())
    if (true)  visitor = ComposedVisitor.new(visitor, EnumTransform.new())
    if (true)  visitor = ComposedVisitor.new(visitor, StrictEqualityTransform.new())
    if (true)  visitor = ComposedVisitor.new(visitor, ThisModuleTransform.new())

    // Optimization
    if (true)  visitor = ComposedVisitor.new(visitor, ConstantFoldingTransform.new())

    // Output AST validation
    if (false) visitor = ComposedVisitor.new(visitor, CallReceiverValidator.new());

    ast.accept(visitor);
    file.close()

    if (_reporter.has_errors) {
      System.print("Build has errors")
      return 1
    }
  }
}
